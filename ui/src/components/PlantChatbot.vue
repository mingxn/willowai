<template>
  <div>
    <div class="chat-container">
      <!-- Sidebar -->
      <div class="sidebar">
        <div class="logo">
          <h1>üåø Plant AI</h1>
          <p>Chatbot ph√¢n t√≠ch c√¢y tr·ªìng</p>
        </div>

        <div class="chat-info">
          <h3><i class="fas fa-info-circle"></i> T√≠nh nƒÉng</h3>
          <ul>
            <li>Nh·∫≠n d·∫°ng c√¢y tr·ªìng</li>
            <li>Ph√°t hi·ªán b·ªánh</li>
            <li>Ph√¢n t√≠ch sinh tr∆∞·ªüng</li>
            <li>Khuy·∫øn ngh·ªã chƒÉm s√≥c</li>
            <li>T∆∞ v·∫•n tr·ª±c ti·∫øp</li>
            <li>L·ªãch chƒÉm s√≥c c√¢y</li>
          </ul>
        </div>

        <div class="chat-info">
          <h3><i class="fas fa-calendar-alt"></i> L·ªãch chƒÉm s√≥c</h3>
          <div class="schedule-stats">
            <p>
              <strong>{{ careSchedules.length }}</strong> l·ªãch ƒë√£ t·∫°o
            </p>
            <p>
              <strong>{{ upcomingReminders.length }}</strong> nh·∫Øc nh·ªü s·∫Øp t·ªõi
            </p>
          </div>
          <button @click="showScheduleModal = true" class="create-schedule-btn">
            <i class="fas fa-plus"></i> T·∫°o l·ªãch m·ªõi
          </button>
          <button @click="showScheduleList = true" class="view-schedule-btn">
            <i class="fas fa-calendar-check"></i> Xem l·ªãch
          </button>
        </div>

        <div class="chat-info">
          <h3><i class="fas fa-image"></i> H·ªó tr·ª£ ƒë·ªãnh d·∫°ng</h3>
          <ul>
            <li>JPG, JPEG</li>
            <li>PNG, WEBP</li>
            <li>T·ªëi ƒëa 10MB</li>
          </ul>
        </div>

        <div class="chat-info">
          <h3><i class="fas fa-clock"></i> Tr·∫°ng th√°i API</h3>
          <ul>
            <li v-if="apiStatus.connected" style="color: #2ecc71">
              <i class="fas fa-check-circle"></i> ƒê√£ k·∫øt n·ªëi
            </li>
            <li v-else style="color: #e74c3c">
              <i class="fas fa-times-circle"></i> M·∫•t k·∫øt n·ªëi
            </li>
          </ul>
        </div>
      </div>

      <!-- Main Chat -->
      <div class="main-chat">
        <div class="chat-header">
          <h2>üí¨ Chatbot Ph√¢n T√≠ch C√¢y Tr·ªìng</h2>
          <p>G·ª≠i h√¨nh ·∫£nh c√¢y c·ªßa b·∫°n v√† ƒë·∫∑t c√¢u h·ªèi ƒë·ªÉ nh·∫≠n t∆∞ v·∫•n</p>
        </div>

        <div class="chat-messages" ref="messagesContainer">
          <!-- Welcome message -->
          <div class="message bot" v-if="messages.length === 0">
            <div class="message-content">
              <strong>üëã Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi Plant Analysis AI!</strong
              ><br /><br />
              T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:
              <ul style="margin: 10px 0; padding-left: 20px">
                <li>üì∏ Ph√¢n t√≠ch h√¨nh ·∫£nh c√¢y tr·ªìng</li>
                <li>üîç Nh·∫≠n d·∫°ng lo·∫°i c√¢y</li>
                <li>ü©∫ Ch·∫©n ƒëo√°n b·ªánh tr√™n c√¢y</li>
                <li>üìà ƒê√°nh gi√° t√¨nh tr·∫°ng sinh tr∆∞·ªüng</li>
                <li>üí° ƒê∆∞a ra khuy·∫øn ngh·ªã chƒÉm s√≥c</li>
                <li>ü§ñ <strong>T·ª± ƒë·ªông t·∫°o l·ªãch chƒÉm s√≥c</strong></li>
              </ul>
              <div
                style="
                  background: #e8f5e8;
                  padding: 10px;
                  border-radius: 8px;
                  margin-top: 10px;
                  border-left: 4px solid #2ecc71;
                "
              >
                <strong>üÜï T√≠nh nƒÉng m·ªõi:</strong> Sau khi ph√¢n t√≠ch h√¨nh ·∫£nh,
                t√¥i s·∫Ω t·ª± ƒë·ªông ƒë·ªÅ xu·∫•t v√† t·∫°o l·ªãch chƒÉm s√≥c ph√π h·ª£p v·ªõi t·ª´ng
                lo·∫°i c√¢y!
              </div>
              <br />
              H√£y g·ª≠i h√¨nh ·∫£nh c√¢y c·ªßa b·∫°n ho·∫∑c ƒë·∫∑t c√¢u h·ªèi ƒë·ªÉ b·∫Øt ƒë·∫ßu!
            </div>
          </div>

          <!-- Chat messages -->
          <div
            v-for="message in messages"
            :key="message.id"
            :class="['message', message.type]"
          >
            <div class="message-content">
              <div v-if="message.image" class="image-preview">
                <img :src="message.image" alt="Uploaded image" />
              </div>

              <div v-html="message.content"></div>

              <div v-if="message.analysis" class="analysis-result">
                <div
                  class="analysis-section"
                  v-if="message.analysis.plant_info"
                >
                  <h4><i class="fas fa-seedling"></i> Nh·∫≠n d·∫°ng c√¢y</h4>
                  <p>
                    <strong>T√™n khoa h·ªçc:</strong>
                    {{
                      message.analysis.plant_info.scientific_name ||
                      "Ch∆∞a x√°c ƒë·ªãnh"
                    }}
                  </p>
                  <p>
                    <strong>T√™n th√¥ng th∆∞·ªùng:</strong>
                    {{
                      message.analysis.plant_info.common_name || "Ch∆∞a x√°c ƒë·ªãnh"
                    }}
                  </p>
                  <p>
                    <strong>ƒê·ªô tin c·∫≠y:</strong>
                    {{ message.analysis.plant_info.confidence || "N/A" }}%
                  </p>
                </div>

                <div
                  class="analysis-section"
                  v-if="message.analysis.health_status"
                >
                  <h4><i class="fas fa-heartbeat"></i> T√¨nh tr·∫°ng s·ª©c kh·ªèe</h4>
                  <p>
                    <strong>Tr·∫°ng th√°i:</strong>
                    {{ message.analysis.health_status.overall_status }}
                  </p>
                  <p v-if="message.analysis.health_status.severity_level">
                    <strong>M·ª©c ƒë·ªô:</strong>
                    {{ message.analysis.health_status.severity_level }}
                  </p>
                </div>

                <div
                  class="analysis-section"
                  v-if="message.analysis.recommendations"
                >
                  <h4><i class="fas fa-lightbulb"></i> Khuy·∫øn ngh·ªã</h4>
                  <ul v-if="message.analysis.recommendations.treatment_steps">
                    <li
                      v-for="step in message.analysis.recommendations
                        .treatment_steps"
                      :key="step"
                    >
                      {{ step }}
                    </li>
                  </ul>
                </div>
              </div>

              <div class="message-time">
                {{ formatTime(message.timestamp) }}
              </div>
            </div>
          </div>

          <!-- Typing indicator -->
          <div v-if="isTyping" class="typing-indicator">
            <div class="typing-dots">
              <span></span>
              <span></span>
              <span></span>
            </div>
            <span class="typing-text">ƒêang ph√¢n t√≠ch...</span>
          </div>
        </div>

        <!-- Chat Input -->
        <div class="chat-input-container">
          <div v-if="errorMessage" class="error-message">
            <i class="fas fa-exclamation-triangle"></i> {{ errorMessage }}
          </div>

          <div v-if="successMessage" class="success-message">
            <i class="fas fa-check"></i> {{ successMessage }}
          </div>

          <div class="chat-input-wrapper">
            <div class="image-upload">
              <input
                type="file"
                id="imageInput"
                @change="handleImageUpload"
                accept="image/*"
              />
              <label
                for="imageInput"
                :class="{ 'has-image': selectedImage }"
                :title="selectedImage ? 'ƒê√£ ch·ªçn h√¨nh ·∫£nh' : 'Upload h√¨nh ·∫£nh'"
              >
                <i
                  :class="selectedImage ? 'fas fa-check' : 'fas fa-camera'"
                ></i>
              </label>
            </div>
            <textarea
              v-model="currentMessage"
              @keydown="handleKeydown"
              placeholder="G·ª≠i h√¨nh ·∫£nh ho·∫∑c ƒë·∫∑t c√¢u h·ªèi v·ªÅ c√¢y tr·ªìng..."
              class="chat-input"
              :disabled="isTyping"
            ></textarea>

            <button
              @click="sendMessage"
              :disabled="isTyping || (!currentMessage.trim() && !selectedImage)"
              class="send-button"
              title="G·ª≠i tin nh·∫Øn"
            >
              <i class="fas fa-paper-plane"></i>
            </button>
          </div>
        </div>
      </div>

      <!-- Schedule Modal -->
      <div
        v-if="showScheduleModal"
        class="modal-overlay"
        @click="closeScheduleModal"
      >
        <div class="modal-content" @click.stop>
          <div class="modal-header">
            <h3><i class="fas fa-calendar-plus"></i> T·∫°o l·ªãch chƒÉm s√≥c c√¢y</h3>
            <button @click="showScheduleModal = false" class="close-btn">
              <i class="fas fa-times"></i>
            </button>
          </div>

          <div class="modal-body">
            <div class="form-group">
              <label><i class="fas fa-seedling"></i> T√™n c√¢y:</label>
              <input
                v-model="newSchedule.plantName"
                type="text"
                placeholder="VD: C√¢y hoa h·ªìng"
              />
            </div>

            <div class="form-group">
              <label><i class="fas fa-tasks"></i> Lo·∫°i chƒÉm s√≥c:</label>
              <select v-model="newSchedule.careType">
                <option value="watering">üíß T∆∞·ªõi n∆∞·ªõc</option>
                <option value="fertilizing">üå± B√≥n ph√¢n</option>
                <option value="pruning">‚úÇÔ∏è T·ªâa c√†nh</option>
                <option value="repotting">ü™¥ Thay ch·∫≠u</option>
                <option value="spraying">üí® Phun thu·ªëc</option>
                <option value="checking">üîç Ki·ªÉm tra s·ª©c kh·ªèe</option>
              </select>
            </div>

            <div class="form-group">
              <label><i class="fas fa-clock"></i> Th·ªùi gian b·∫Øt ƒë·∫ßu:</label>
              <input v-model="newSchedule.startDate" type="datetime-local" />
            </div>

            <div class="form-group">
              <label><i class="fas fa-redo"></i> L·∫∑p l·∫°i:</label>
              <select v-model="newSchedule.repeatType">
                <option value="none">Kh√¥ng l·∫∑p l·∫°i</option>
                <option value="daily">H√†ng ng√†y</option>
                <option value="weekly">H√†ng tu·∫ßn</option>
                <option value="monthly">H√†ng th√°ng</option>
              </select>
            </div>

            <div v-if="newSchedule.repeatType !== 'none'" class="form-group">
              <label><i class="fas fa-hashtag"></i> S·ªë l·∫ßn l·∫∑p:</label>
              <input
                v-model="newSchedule.repeatCount"
                type="number"
                min="1"
                max="365"
                placeholder="VD: 30"
              />
            </div>

            <div class="form-group">
              <label><i class="fas fa-sticky-note"></i> Ghi ch√∫:</label>
              <textarea
                v-model="newSchedule.notes"
                placeholder="Ghi ch√∫ th√™m v·ªÅ c√°ch chƒÉm s√≥c..."
              ></textarea>
            </div>
          </div>

          <div class="modal-footer">
            <button @click="showScheduleModal = false" class="btn-secondary">
              <i class="fas fa-times"></i> H·ªßy
            </button>
            <button
              @click="createSchedule"
              class="btn-primary"
              :disabled="!isScheduleValid"
            >
              <i class="fas fa-save"></i> T·∫°o l·ªãch
            </button>
          </div>
        </div>
      </div>

      <!-- Schedule List Modal -->
      <div
        v-if="showScheduleList"
        class="modal-overlay"
        @click="closeScheduleList"
      >
        <div class="modal-content schedule-list-modal" @click.stop>
          <div class="modal-header">
            <h3><i class="fas fa-calendar-check"></i> L·ªãch chƒÉm s√≥c c·ªßa b·∫°n</h3>
            <button @click="showScheduleList = false" class="close-btn">
              <i class="fas fa-times"></i>
            </button>
          </div>

          <div class="modal-body">
            <div class="schedule-tabs">
              <button
                :class="['tab-btn', { active: activeTab === 'upcoming' }]"
                @click="activeTab = 'upcoming'"
              >
                <i class="fas fa-clock"></i> S·∫Øp t·ªõi ({{
                  upcomingReminders.length
                }})
              </button>
              <button
                :class="['tab-btn', { active: activeTab === 'all' }]"
                @click="activeTab = 'all'"
              >
                <i class="fas fa-list"></i> T·∫•t c·∫£ ({{ careSchedules.length }})
              </button>
            </div>

            <div class="schedule-content">
              <div v-if="activeTab === 'upcoming'" class="upcoming-reminders">
                <div v-if="upcomingReminders.length === 0" class="empty-state">
                  <i class="fas fa-calendar-times"></i>
                  <p>Kh√¥ng c√≥ nh·∫Øc nh·ªü n√†o s·∫Øp t·ªõi</p>
                </div>
                <div v-else>
                  <div
                    v-for="reminder in upcomingReminders"
                    :key="reminder.id"
                    class="reminder-item urgent"
                  >
                    <div class="reminder-icon">
                      {{ getCareTypeIcon(reminder.careType) }}
                    </div>
                    <div class="reminder-info">
                      <h4>{{ reminder.plantName }}</h4>
                      <p>{{ getCareTypeName(reminder.careType) }}</p>
                      <span class="reminder-time">{{
                        formatReminderTime(reminder.nextDate)
                      }}</span>
                    </div>
                    <button @click="markAsDone(reminder.id)" class="done-btn">
                      <i class="fas fa-check"></i>
                    </button>
                  </div>
                </div>
              </div>

              <div v-if="activeTab === 'all'" class="all-schedules">
                <div v-if="careSchedules.length === 0" class="empty-state">
                  <i class="fas fa-seedling"></i>
                  <p>Ch∆∞a c√≥ l·ªãch chƒÉm s√≥c n√†o</p>
                  <button
                    @click="
                      showScheduleModal = true;
                      showScheduleList = false;
                    "
                    class="btn-primary"
                  >
                    <i class="fas fa-plus"></i> T·∫°o l·ªãch ƒë·∫ßu ti√™n
                  </button>
                </div>
                <div v-else>
                  <div
                    v-for="schedule in careSchedules"
                    :key="schedule.id"
                    class="schedule-item"
                  >
                    <div class="schedule-icon">
                      {{ getCareTypeIcon(schedule.careType) }}
                    </div>
                    <div class="schedule-info">
                      <h4>
                        {{ schedule.plantName }}
                        <span v-if="schedule.autoGenerated" class="auto-badge"
                          >ü§ñ AI</span
                        >
                      </h4>
                      <p>{{ getCareTypeName(schedule.careType) }}</p>
                      <span class="schedule-repeat">{{
                        getRepeatText(schedule)
                      }}</span>
                      <p v-if="schedule.notes" class="schedule-notes">
                        {{ schedule.notes }}
                      </p>
                    </div>
                    <div class="schedule-actions">
                      <button
                        @click="viewScheduleDetails(schedule)"
                        class="view-btn"
                        title="Xem chi ti·∫øt"
                      >
                        <i class="fas fa-eye"></i>
                      </button>
                      <button
                        @click="editSchedule(schedule)"
                        class="edit-btn"
                        title="Ch·ªânh s·ª≠a"
                      >
                        <i class="fas fa-edit"></i>
                      </button>
                      <button
                        @click="deleteSchedule(schedule.id)"
                        class="delete-btn"
                        title="X√≥a"
                      >
                        <i class="fas fa-trash"></i>
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal Chi ti·∫øt L·ªãch -->
    <div
      v-if="showScheduleDetails"
      class="modal-overlay"
      @click="closeScheduleDetails"
    >
      <div class="modal-content schedule-details-modal" @click.stop>
        <div class="modal-header">
          <h3>üìÖ Chi ti·∫øt L·ªãch ChƒÉm s√≥c</h3>
          <button @click="showScheduleDetails = false" class="close-btn">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body" v-if="selectedSchedule">
          <div class="schedule-detail-section">
            <div class="detail-item">
              <label>üå± T√™n c√¢y:</label>
              <span class="detail-value">{{ selectedSchedule.plantName }}</span>
              <span v-if="selectedSchedule.autoGenerated" class="auto-badge"
                >ü§ñ AI</span
              >
            </div>

            <div class="detail-item">
              <label>üîß Lo·∫°i chƒÉm s√≥c:</label>
              <span class="detail-value">
                {{ getCareTypeIcon(selectedSchedule.careType) }}
                {{ getCareTypeName(selectedSchedule.careType) }}
              </span>
            </div>

            <div class="detail-item">
              <label>üìÖ Ng√†y b·∫Øt ƒë·∫ßu:</label>
              <span class="detail-value">{{
                formatDateTime(selectedSchedule.startDate)
              }}</span>
            </div>

            <div class="detail-item">
              <label>üîÑ L·∫∑p l·∫°i:</label>
              <span class="detail-value">{{
                getRepeatText(selectedSchedule)
              }}</span>
            </div>

            <div class="detail-item" v-if="selectedSchedule.repeatCount">
              <label>üî¢ S·ªë l·∫ßn l·∫∑p:</label>
              <span class="detail-value"
                >{{ selectedSchedule.repeatCount }} l·∫ßn</span
              >
            </div>

            <div class="detail-item" v-if="selectedSchedule.notes">
              <label>üìù Ghi ch√∫:</label>
              <span class="detail-value notes-text">{{
                selectedSchedule.notes
              }}</span>
            </div>

            <div class="detail-item">
              <label>‚è∞ Tr·∫°ng th√°i:</label>
              <span class="detail-value status-active">ƒêang ho·∫°t ƒë·ªông</span>
            </div>

            <div class="detail-item">
              <label>üìä Ti·∫øn ƒë·ªô:</label>
              <div class="progress-info">
                <span class="detail-value">{{
                  getScheduleProgress(selectedSchedule)
                }}</span>
                <div class="progress-bar">
                  <div
                    class="progress-fill"
                    :style="{
                      width: getProgressPercentage(selectedSchedule) + '%',
                    }"
                  ></div>
                </div>
              </div>
            </div>

            <div class="detail-item" v-if="getNextReminder(selectedSchedule)">
              <label>‚è∞ Nh·∫Øc nh·ªü ti·∫øp theo:</label>
              <span class="detail-value next-reminder">
                {{ formatDateTime(getNextReminder(selectedSchedule)) }}
                <small
                  >({{
                    formatReminderTime(getNextReminder(selectedSchedule))
                  }})</small
                >
              </span>
            </div>
          </div>

          <div class="schedule-actions-detail">
            <button @click="editSchedule(selectedSchedule)" class="btn-primary">
              <i class="fas fa-edit"></i> Ch·ªânh s·ª≠a
            </button>
            <button
              @click="duplicateSchedule(selectedSchedule)"
              class="btn-secondary"
            >
              <i class="fas fa-copy"></i> Sao ch√©p
            </button>
            <button
              @click="deleteSchedule(selectedSchedule.id)"
              class="btn-danger"
            >
              <i class="fas fa-trash"></i> X√≥a
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
<script>
import axios from "axios";

export default {
  name: "PlantChatbot",
  data() {
    return {
      messages: [],
      currentMessage: "",
      selectedImage: null,
      selectedImageFile: null,
      isTyping: false,
      errorMessage: "",
      successMessage: "",
      apiStatus: {
        connected: false,
      },
      messageId: 1,
      apiBaseUrl: "http://127.0.0.1:8000",

      // Schedule management
      showScheduleModal: false,
      showScheduleList: false,
      showScheduleDetails: false,
      selectedSchedule: null,
      activeTab: "upcoming",
      careSchedules: [],
      newSchedule: {
        plantName: "",
        careType: "watering",
        startDate: "",
        repeatType: "none",
        repeatCount: 1,
        notes: "",
      },
      scheduleIdCounter: 1,
      reminderCheckInterval: null,
    };
  },
  computed: {
    upcomingReminders() {
      const now = new Date();
      const next24Hours = new Date(now.getTime() + 24 * 60 * 60 * 1000);

      return this.careSchedules
        .filter((schedule) => {
          const nextDate = this.getNextReminderDate(schedule);
          return nextDate && nextDate <= next24Hours && nextDate >= now;
        })
        .map((schedule) => ({
          ...schedule,
          nextDate: this.getNextReminderDate(schedule),
        }))
        .sort((a, b) => a.nextDate - b.nextDate);
    },

    isScheduleValid() {
      return (
        this.newSchedule.plantName.trim() &&
        this.newSchedule.startDate &&
        this.newSchedule.careType
      );
    },
  },
  mounted() {
    this.checkApiStatus();
    this.scrollToBottom();
    this.loadSchedulesFromStorage();
    this.setupReminderCheck();
    this.setDefaultStartDate();
    this.requestNotificationPermission();
  },
  beforeUnmount() {
    if (this.reminderCheckInterval) {
      clearInterval(this.reminderCheckInterval);
    }
  },
  methods: {
    async checkApiStatus() {
      try {
        const response = await axios.get(`${this.apiBaseUrl}/health`);
        this.apiStatus.connected = response.data.status === "healthy";
      } catch (error) {
        this.apiStatus.connected = false;
      }
    },

    handleImageUpload(event) {
      const file = event.target.files[0];
      if (file) {
        // Validate file size (10MB)
        if (file.size > 10 * 1024 * 1024) {
          this.showError("File qu√° l·ªõn. Vui l√≤ng ch·ªçn file nh·ªè h∆°n 10MB.");
          return;
        }

        // Validate file type
        const allowedTypes = [
          "image/jpeg",
          "image/jpg",
          "image/png",
          "image/webp",
        ];
        if (!allowedTypes.includes(file.type)) {
          this.showError(
            "ƒê·ªãnh d·∫°ng file kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£. Vui l√≤ng ch·ªçn JPG, PNG ho·∫∑c WEBP."
          );
          return;
        }

        this.selectedImageFile = file;

        // Create preview
        const reader = new FileReader();
        reader.onload = (e) => {
          this.selectedImage = e.target.result;
        };
        reader.readAsDataURL(file);

        this.showSuccess("ƒê√£ ch·ªçn h√¨nh ·∫£nh. Nh·∫•n g·ª≠i ƒë·ªÉ ph√¢n t√≠ch.");
      }
    },

    handleKeydown(event) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        this.sendMessage();
      }
    },

    async sendMessage() {
      if (this.isTyping) return;

      // Validate input
      if (!this.currentMessage.trim() && !this.selectedImage) {
        this.showError("Vui l√≤ng nh·∫≠p tin nh·∫Øn ho·∫∑c ch·ªçn h√¨nh ·∫£nh.");
        return;
      }

      // Clear previous messages
      this.clearMessages();

      // Add user message
      const userMessage = {
        id: this.messageId++,
        type: "user",
        content: this.currentMessage || "Ph√¢n t√≠ch h√¨nh ·∫£nh n√†y",
        image: this.selectedImage,
        timestamp: new Date(),
      };
      this.messages.push(userMessage);

      // Clear input
      const messageToSend = this.currentMessage;
      const imageToSend = this.selectedImageFile;
      this.currentMessage = "";
      this.selectedImage = null;
      this.selectedImageFile = null;
      document.getElementById("imageInput").value = "";

      this.scrollToBottom();

      // Show typing indicator
      this.isTyping = true;

      try {
        let botResponse;

        if (imageToSend) {
          // Analyze image
          botResponse = await this.analyzeImage(imageToSend);
        } else {
          // Text-only message
          botResponse = await this.handleTextMessage(messageToSend);
        }

        // Add bot response
        const botMessage = {
          id: this.messageId++,
          type: "bot",
          content: botResponse.content,
          analysis: botResponse.analysis,
          timestamp: new Date(),
        };
        this.messages.push(botMessage);

        // Auto-generate care schedule if image analysis was successful
        if (imageToSend && botResponse.analysis && botResponse.plantInfo) {
          await this.autoGenerateCareSchedule(
            botResponse.plantInfo,
            botResponse.analysis
          );
        }
      } catch (error) {
        console.error("Error:", error);
        const errorMessage = {
          id: this.messageId++,
          type: "bot",
          content:
            "‚ùå Xin l·ªói, ƒë√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i.",
          timestamp: new Date(),
        };
        this.messages.push(errorMessage);
      } finally {
        this.isTyping = false;
        this.scrollToBottom();
      }
    },

    async analyzeImage(imageFile) {
      const formData = new FormData();
      formData.append("file", imageFile);
      formData.append("enhance_image", "true");

      const response = await axios.post(
        `${this.apiBaseUrl}/analyze/complete`,
        formData,
        {
          headers: {
            "Content-Type": "multipart/form-data",
          },
        }
      );

      const result = response.data;

      if (result.success) {
        // Parse and format the analysis text properly
        let analysisContent = "";

        if (result.analysis_text) {
          // Try to extract JSON from analysis_text
          let jsonMatch = result.analysis_text.match(
            /```json\s*([\s\S]*?)\s*```/
          );
          if (jsonMatch) {
            try {
              const jsonData = JSON.parse(jsonMatch[1]);
              analysisContent = this.formatStructuredAnalysis(jsonData);
            } catch (e) {
              // If JSON parsing fails, format as text
              analysisContent = this.formatAnalysisText(result.analysis_text);
            }
          } else {
            analysisContent = this.formatAnalysisText(result.analysis_text);
          }
        } else {
          analysisContent = "Kh√¥ng th·ªÉ ph√¢n t√≠ch ƒë∆∞·ª£c h√¨nh ·∫£nh n√†y.";
        }

        return {
          content: analysisContent,
          analysis: result.structured_data,
          plantInfo: this.extractPlantInfo(
            result.analysis_text,
            result.structured_data
          ),
        };
      } else {
        throw new Error(result.error || "Ph√¢n t√≠ch th·∫•t b·∫°i");
      }
    },

    formatStructuredAnalysis(data) {
      let formatted = "üìä <strong>K·∫øt qu·∫£ ph√¢n t√≠ch chi ti·∫øt:</strong><br><br>";

      // Process each section
      for (const [key, value] of Object.entries(data)) {
        const sectionNumber = key.match(/^\d+/);

        if (key.includes("NH·∫¨N D·∫†NG") || key.includes("1.")) {
          formatted += "üîç <strong>NH·∫¨N D·∫†NG C√ÇY</strong><br>";
          formatted += this.formatPlantIdentification(value) + "<br>";
        } else if (key.includes("T√åNH TR·∫†NG") || key.includes("2.")) {
          formatted += "‚öïÔ∏è <strong>T√åNH TR·∫†NG S·ª®C KH·ªéE</strong><br>";
          formatted += this.formatHealthStatus(value) + "<br>";
        } else if (key.includes("SINH TR∆Ø·ªûNG") || key.includes("3.")) {
          formatted += "üìà <strong>PH√ÇN T√çCH SINH TR∆Ø·ªûNG</strong><br>";
          formatted += this.formatGrowthAnalysis(value) + "<br>";
        } else if (key.includes("KHUY·∫æN NGH·ªä") || key.includes("4.")) {
          formatted += "üí° <strong>KHUY·∫æN NGH·ªä CHƒÇM S√ìC</strong><br>";
          formatted += this.formatRecommendations(value) + "<br>";
        } else if (key.includes("TH√îNG TIN") || key.includes("5.")) {
          formatted += "üìã <strong>TH√îNG TIN B·ªî SUNG</strong><br>";
          formatted += this.formatAdditionalInfo(value) + "<br>";
        }
      }

      return formatted;
    },

    async handleTextMessage(message) {
      // Simple text responses for common questions
      const lowerMessage = message.toLowerCase();

      if (lowerMessage.includes("c√¢y") || lowerMessage.includes("tr·ªìng")) {
        return {
          content: `üå± T√¥i hi·ªÉu b·∫°n mu·ªën h·ªèi v·ªÅ c√¢y tr·ªìng. ƒê·ªÉ t√¥i c√≥ th·ªÉ gi√∫p b·∫°n t·ªët nh·∫•t, h√£y g·ª≠i h√¨nh ·∫£nh c√¢y m√† b·∫°n quan t√¢m. 
          
          T√¥i c√≥ th·ªÉ:
          ‚Ä¢ üì∏ Ph√¢n t√≠ch h√¨nh ·∫£nh ƒë·ªÉ nh·∫≠n d·∫°ng lo·∫°i c√¢y
          ‚Ä¢ üîç Ph√°t hi·ªán c√°c v·∫•n ƒë·ªÅ v·ªÅ s·ª©c kh·ªèe
          ‚Ä¢ üí° ƒê∆∞a ra khuy·∫øn ngh·ªã chƒÉm s√≥c c·ª• th·ªÉ
          
          Nh·∫•n v√†o icon üì∑ ƒë·ªÉ upload h√¨nh ·∫£nh nh√©!`,
        };
      }

      if (
        lowerMessage.includes("l·ªãch") ||
        lowerMessage.includes("nh·∫Øc nh·ªü") ||
        lowerMessage.includes("chƒÉm s√≥c")
      ) {
        return {
          content: `üìÖ T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t·∫°o l·ªãch chƒÉm s√≥c c√¢y!
        
        C√°c t√≠nh nƒÉng l·ªãch chƒÉm s√≥c:
        ‚Ä¢ ‚è∞ ƒê·∫∑t nh·∫Øc nh·ªü t∆∞·ªõi n∆∞·ªõc, b√≥n ph√¢n
        ‚Ä¢ üîÑ L·∫∑p l·∫°i theo chu k·ª≥ (h√†ng ng√†y, tu·∫ßn, th√°ng)
        ‚Ä¢ üìù Ghi ch√∫ chi ti·∫øt cho t·ª´ng ho·∫°t ƒë·ªông
        ‚Ä¢ üîî Th√¥ng b√°o khi ƒë·∫øn gi·ªù chƒÉm s√≥c
        
        Nh·∫•n n√∫t "T·∫°o l·ªãch m·ªõi" ·ªü sidebar ƒë·ªÉ b·∫Øt ƒë·∫ßu!
        
        Ho·∫∑c h·ªèi t√¥i: "T√¥i n√™n t∆∞·ªõi c√¢y bao l√¢u m·ªôt l·∫ßn?" ƒë·ªÉ nh·∫≠n t∆∞ v·∫•n.`,
        };
      }

      if (
        lowerMessage.includes("b·ªánh") ||
        lowerMessage.includes("v√†ng") ||
        lowerMessage.includes("h√©o")
      ) {
        return {
          content: `üî¨ ƒê·ªÉ ch·∫©n ƒëo√°n b·ªánh tr√™n c√¢y ch√≠nh x√°c, t√¥i c·∫ßn xem h√¨nh ·∫£nh c·ªßa c√¢y b·∫°n.
          
          Khi ch·ª•p ·∫£nh, h√£y ch√∫ √Ω:
          ‚Ä¢ üì∏ Ch·ª•p r√µ n√©t ph·∫ßn l√° b·ªã b·ªánh
          ‚Ä¢ ‚òÄÔ∏è Ch·ª•p d∆∞·ªõi √°nh s√°ng t·ª± nhi√™n
          ‚Ä¢ üîç Bao g·ªìm c·∫£ l√° kh·ªèe m·∫°nh ƒë·ªÉ so s√°nh
          ‚Ä¢ üìè Ch·ª•p c·∫£ c√¢y v√† c·∫≠n c·∫£nh v√πng b·ªã b·ªánh
          
          Upload h√¨nh ·∫£nh ƒë·ªÉ t√¥i ph√¢n t√≠ch nh√©!`,
        };
      }

      return {
        content: `üí¨ Xin ch√†o! T√¥i l√† chatbot chuy√™n ph√¢n t√≠ch c√¢y tr·ªìng.
        
        T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:
        ‚Ä¢ üå± Nh·∫≠n d·∫°ng lo·∫°i c√¢y t·ª´ h√¨nh ·∫£nh
        ‚Ä¢ üî¨ Ph√°t hi·ªán b·ªánh v√† s√¢u h·∫°i
        ‚Ä¢ üìà ƒê√°nh gi√° t√¨nh tr·∫°ng sinh tr∆∞·ªüng
        ‚Ä¢ üí° T∆∞ v·∫•n c√°ch chƒÉm s√≥c
        ‚Ä¢ üìÖ T·∫°o l·ªãch chƒÉm s√≥c c√¢y
        
        H√£y g·ª≠i h√¨nh ·∫£nh c√¢y c·ªßa b·∫°n ƒë·ªÉ t√¥i ph√¢n t√≠ch chi ti·∫øt!`,
      };
    },
    formatAnalysisText(analysisText) {
      if (!analysisText) return "";

      // Remove JSON markers and clean up
      let text = analysisText.replace(/```json|```/g, "").trim();

      // Try to parse as JSON first
      try {
        const jsonData = JSON.parse(text);
        return this.formatJsonAnalysis(jsonData);
      } catch (e) {
        // If not JSON, check if it's Vietnamese text
        if (text.includes("NH·∫¨N D·∫†NG") || text.includes("T√åNH TR·∫†NG")) {
          return this.formatVietnameseText(text);
        }
        return text;
      }
    },

    formatVietnameseText(text) {
      // Format Vietnamese text with proper structure
      let formatted = text
        .replace(
          /(\d+\.\s*NH·∫¨N D·∫†NG C√ÇY[^}]*})/g,
          "üîç <strong>NH·∫¨N D·∫†NG C√ÇY</strong><br>$1<br><br>"
        )
        .replace(
          /(\d+\.\s*T√åNH TR·∫†NG S·ª®C KH·ªéE[^}]*})/g,
          "‚öïÔ∏è <strong>T√åNH TR·∫†NG S·ª®C KH·ªéE</strong><br>$1<br><br>"
        )
        .replace(
          /(\d+\.\s*PH√ÇN T√çCH SINH TR∆Ø·ªûNG[^}]*})/g,
          "üìà <strong>PH√ÇN T√çCH SINH TR∆Ø·ªûNG</strong><br>$1<br><br>"
        )
        .replace(
          /(\d+\.\s*KHUY·∫æN NGH·ªä[^}]*})/g,
          "üí° <strong>KHUY·∫æN NGH·ªä CHƒÇM S√ìC</strong><br>$1<br><br>"
        )
        .replace(
          /(\d+\.\s*TH√îNG TIN B·ªî SUNG[^}]*})/g,
          "üìã <strong>TH√îNG TIN B·ªî SUNG</strong><br>$1<br><br>"
        );

      return formatted;
    },

    formatJsonAnalysis(data) {
      let formatted = "üìä <strong>K·∫øt qu·∫£ ph√¢n t√≠ch chi ti·∫øt:</strong><br><br>";

      for (const [key, value] of Object.entries(data)) {
        if (key.includes("NH·∫¨N D·∫†NG") || key.includes("1.")) {
          formatted += "üîç <strong>NH·∫¨N D·∫†NG C√ÇY</strong><br>";
          formatted += this.formatPlantIdentification(value);
        } else if (key.includes("T√åNH TR·∫†NG") || key.includes("2.")) {
          formatted += "<br>‚öïÔ∏è <strong>T√åNH TR·∫†NG S·ª®C KH·ªéE</strong><br>";
          formatted += this.formatHealthStatus(value);
        } else if (key.includes("SINH TR∆Ø·ªûNG") || key.includes("3.")) {
          formatted += "<br>üìà <strong>PH√ÇN T√çCH SINH TR∆Ø·ªûNG</strong><br>";
          formatted += this.formatGrowthAnalysis(value);
        } else if (key.includes("KHUY·∫æN NGH·ªä") || key.includes("4.")) {
          formatted += "<br>üí° <strong>KHUY·∫æN NGH·ªä CHƒÇM S√ìC</strong><br>";
          formatted += this.formatRecommendations(value);
        } else if (key.includes("TH√îNG TIN") || key.includes("5.")) {
          formatted += "<br>üìã <strong>TH√îNG TIN B·ªî SUNG</strong><br>";
          formatted += this.formatAdditionalInfo(value);
        }
      }

      return formatted;
    },

    formatPlantIdentification(data) {
      let result = "";
      
      // Handle different data structures
      if (!data || typeof data !== 'object') {
        return result;
      }
      
      // Check for nested name structure
      if (data["T√™n khoa h·ªçc v√† t√™n th√¥ng th∆∞·ªùng"]) {
        const names = data["T√™n khoa h·ªçc v√† t√™n th√¥ng th∆∞·ªùng"];
        if (typeof names === 'object') {
          result += `üè∑Ô∏è <strong>T√™n khoa h·ªçc:</strong> ${
            names["T√™n khoa h·ªçc"] || "Ch∆∞a x√°c ƒë·ªãnh"
          }<br>`;
          result += `üåø <strong>T√™n th√¥ng th∆∞·ªùng:</strong> ${
            names["T√™n th√¥ng th∆∞·ªùng"] || "Ch∆∞a x√°c ƒë·ªãnh"
          }<br>`;
        } else {
          // If names is a string, display it directly
          result += `üåø <strong>T√™n c√¢y:</strong> ${names}<br>`;
        }
      }
      
      // Check for direct name fields
      if (data["T√™n khoa h·ªçc"]) {
        result += `üè∑Ô∏è <strong>T√™n khoa h·ªçc:</strong> ${data["T√™n khoa h·ªçc"]}<br>`;
      }
      
      if (data["T√™n th√¥ng th∆∞·ªùng"]) {
        result += `üåø <strong>T√™n th√¥ng th∆∞·ªùng:</strong> ${data["T√™n th√¥ng th∆∞·ªùng"]}<br>`;
      }
      
      if (data["H·ªç th·ª±c v·∫≠t"]) {
        result += `üå≥ <strong>H·ªç th·ª±c v·∫≠t:</strong> ${data["H·ªç th·ª±c v·∫≠t"]}<br>`;
      }
      
      if (data["ƒê·ªô tin c·∫≠y nh·∫≠n d·∫°ng (%)"]) {
        result += `üìä <strong>ƒê·ªô tin c·∫≠y:</strong> ${data["ƒê·ªô tin c·∫≠y nh·∫≠n d·∫°ng (%)"]}%<br>`;
      }
      
      // Handle confidence field variations
      if (data["confidence"]) {
        result += `üìä <strong>ƒê·ªô tin c·∫≠y:</strong> ${data["confidence"]}%<br>`;
      }
      
      // If no specific fields found, try to display any text content
      if (!result) {
        for (const [key, value] of Object.entries(data)) {
          if (typeof value === 'string' && value.trim() && !key.includes(':')) {
            result += `üåø <strong>${key}:</strong> ${value}<br>`;
          }
        }
      }
      
      return result;
    },

    formatHealthStatus(data) {
      let result = "";
      if (data["T√¨nh tr·∫°ng t·ªïng th·ªÉ"]) {
        const status = data["T√¨nh tr·∫°ng t·ªïng th·ªÉ"];
        const statusIcon =
          status === "Kh·ªèe m·∫°nh" ? "üíö" : status === "B·ªánh" ? "‚ù§Ô∏è‚Äçü©π" : "‚ö†Ô∏è";
        result += `${statusIcon} <strong>Tr·∫°ng th√°i:</strong> ${status}<br>`;
      }
      if (data["T√™n b·ªánh c√≥ th·ªÉ"]) {
        result += `ü¶† <strong>B·ªánh:</strong> ${data["T√™n b·ªánh c√≥ th·ªÉ"]}<br>`;
      }
      if (data["M·ª©c ƒë·ªô nghi√™m tr·ªçng"]) {
        result += `‚öñÔ∏è <strong>M·ª©c ƒë·ªô:</strong> ${data["M·ª©c ƒë·ªô nghi√™m tr·ªçng"]}<br>`;
      }
      return result;
    },

    formatGrowthAnalysis(data) {
      let result = "";
      if (data["Giai ƒëo·∫°n ph√°t tri·ªÉn"]) {
        result += `üå± <strong>Giai ƒëo·∫°n:</strong> ${data["Giai ƒëo·∫°n ph√°t tri·ªÉn"]}<br>`;
      }
      if (data["T√¨nh tr·∫°ng dinh d∆∞·ª°ng"]) {
        result += `üçÉ <strong>Dinh d∆∞·ª°ng:</strong> ${data["T√¨nh tr·∫°ng dinh d∆∞·ª°ng"]}<br>`;
      }
      if (data["T·ªëc ƒë·ªô sinh tr∆∞·ªüng"]) {
        result += `üìà <strong>T·ªëc ƒë·ªô ph√°t tri·ªÉn:</strong> ${data["T·ªëc ƒë·ªô sinh tr∆∞·ªüng"]}<br>`;
      }
      return result;
    },

    formatRecommendations(data) {
      let result = "";
      if (data["Bi·ªán ph√°p ƒëi·ªÅu tr·ªã"]) {
        result += `üíä <strong>ƒêi·ªÅu tr·ªã:</strong><br>`;
        const treatment = data["Bi·ªán ph√°p ƒëi·ªÅu tr·ªã"];
        if (typeof treatment === "object") {
          for (const [key, value] of Object.entries(treatment)) {
            result += `&nbsp;&nbsp;‚Ä¢ ${value}<br>`;
          }
        } else {
          result += `&nbsp;&nbsp;‚Ä¢ ${treatment}<br>`;
        }
      }
      if (data["C√°ch chƒÉm s√≥c t·ªëi ∆∞u"]) {
        result += `üåü <strong>ChƒÉm s√≥c:</strong><br>`;
        const care = data["C√°ch chƒÉm s√≥c t·ªëi ∆∞u"];
        if (typeof care === "object") {
          for (const [key, value] of Object.entries(care)) {
            result += `&nbsp;&nbsp;‚Ä¢ ${value}<br>`;
          }
        } else {
          result += `&nbsp;&nbsp;‚Ä¢ ${care}<br>`;
        }
      }
      return result;
    },

    formatAdditionalInfo(data) {
      let result = "";
      if (data["Ngu·ªìn g·ªëc c√¢y"]) {
        result += `üåç <strong>Ngu·ªìn g·ªëc:</strong> ${data["Ngu·ªìn g·ªëc c√¢y"]}<br>`;
      }
      if (data["M√πa sinh tr∆∞·ªüng t·ªët nh·∫•t"]) {
        result += `üóìÔ∏è <strong>M√πa t·ªët nh·∫•t:</strong> ${data["M√πa sinh tr∆∞·ªüng t·ªët nh·∫•t"]}<br>`;
      }
      if (data["ƒêi·ªÅu ki·ªán tr·ªìng l√Ω t∆∞·ªüng"]) {
        result += `üè° <strong>ƒêi·ªÅu ki·ªán l√Ω t∆∞·ªüng:</strong><br>`;
        const conditions = data["ƒêi·ªÅu ki·ªán tr·ªìng l√Ω t∆∞·ªüng"];
        for (const [key, value] of Object.entries(conditions)) {
          result += `&nbsp;&nbsp;‚Ä¢ ${key}: ${value}<br>`;
        }
      }
      return result;
    },

    formatJsonValue(value, indent = 0) {
      const indentStr = "&nbsp;".repeat(indent * 4);

      if (typeof value === "object" && value !== null) {
        let result = "";
        for (const [k, v] of Object.entries(value)) {
          result += `${indentStr}‚Ä¢ <strong>${k}:</strong> `;
          if (typeof v === "object") {
            result += "<br>" + this.formatJsonValue(v, indent + 1);
          } else {
            result += `${v}<br>`;
          }
        }
        return result;
      }

      return `${indentStr}${value}<br>`;
    },

    formatTime(timestamp) {
      return timestamp.toLocaleTimeString("vi-VN", {
        hour: "2-digit",
        minute: "2-digit",
      });
    },

    scrollToBottom() {
      this.$nextTick(() => {
        const container = this.$refs.messagesContainer;
        if (container) {
          container.scrollTop = container.scrollHeight;
        }
      });
    },

    showError(message) {
      this.errorMessage = message;
      setTimeout(() => {
        this.errorMessage = "";
      }, 5000);
    },

    showSuccess(message) {
      this.successMessage = message;
      setTimeout(() => {
        this.successMessage = "";
      }, 3000);
    },

    clearMessages() {
      this.errorMessage = "";
      this.successMessage = "";
    },

    // Schedule Management Methods
    setDefaultStartDate() {
      const now = new Date();
      now.setMinutes(now.getMinutes() + 30); // 30 minutes from now
      this.newSchedule.startDate = now.toISOString().slice(0, 16);
    },

    loadSchedulesFromStorage() {
      const saved = localStorage.getItem("plantCareSchedules");
      if (saved) {
        try {
          const schedules = JSON.parse(saved);
          // Ensure all dates are properly parsed
          this.careSchedules = schedules.map(schedule => ({
            ...schedule,
            startDate: new Date(schedule.startDate),
            createdAt: schedule.createdAt ? new Date(schedule.createdAt) : new Date(),
            completedDates: schedule.completedDates ? 
              schedule.completedDates.map(date => new Date(date)) : []
          }));
          this.scheduleIdCounter =
            Math.max(...this.careSchedules.map((s) => s.id), 0) + 1;
        } catch (error) {
          console.error("Error loading schedules:", error);
          this.careSchedules = [];
          this.scheduleIdCounter = 1;
        }
      }
    },

    saveSchedulesToStorage() {
      localStorage.setItem(
        "plantCareSchedules",
        JSON.stringify(this.careSchedules)
      );
    },

    createSchedule() {
      if (!this.isScheduleValid) return;

      const schedule = {
        id: this.scheduleIdCounter++,
        plantName: this.newSchedule.plantName.trim(),
        careType: this.newSchedule.careType,
        startDate: new Date(this.newSchedule.startDate),
        repeatType: this.newSchedule.repeatType,
        repeatCount: parseInt(this.newSchedule.repeatCount) || 1,
        notes: this.newSchedule.notes.trim(),
        completedDates: [],
        createdAt: new Date(),
      };

      this.careSchedules.push(schedule);
      this.saveSchedulesToStorage();

      // Reset form
      this.newSchedule = {
        plantName: "",
        careType: "watering",
        startDate: "",
        repeatType: "none",
        repeatCount: 1,
        notes: "",
      };
      this.setDefaultStartDate();

      this.showScheduleModal = false;
      this.showSuccess(`ƒê√£ t·∫°o l·ªãch chƒÉm s√≥c cho ${schedule.plantName}`);

      // Add bot message about schedule creation
      const botMessage = {
        id: this.messageId++,
        type: "bot",
        content: `‚úÖ ƒê√£ t·∫°o l·ªãch chƒÉm s√≥c th√†nh c√¥ng!
        
        üìã **${schedule.plantName}**
        ${this.getCareTypeIcon(schedule.careType)} ${this.getCareTypeName(
          schedule.careType
        )}
        ‚è∞ B·∫Øt ƒë·∫ßu: ${this.formatDateTime(schedule.startDate)}
        üîÑ ${this.getRepeatText(schedule)}
        
        T√¥i s·∫Ω nh·∫Øc nh·ªü b·∫°n khi ƒë·∫øn gi·ªù chƒÉm s√≥c!`,
        timestamp: new Date(),
      };
      this.messages.push(botMessage);
      this.scrollToBottom();
    },

    editSchedule(schedule) {
      // Ensure startDate is a Date object
      const startDate = schedule.startDate instanceof Date 
        ? schedule.startDate 
        : new Date(schedule.startDate);
      
      this.newSchedule = {
        plantName: schedule.plantName,
        careType: schedule.careType,
        startDate: startDate.toISOString().slice(0, 16),
        repeatType: schedule.repeatType,
        repeatCount: schedule.repeatCount,
        notes: schedule.notes,
      };
      this.newSchedule.editingId = schedule.id;
      this.showScheduleList = false;
      this.showScheduleModal = true;
    },

    deleteSchedule(scheduleId) {
      if (confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a l·ªãch chƒÉm s√≥c n√†y?")) {
        this.careSchedules = this.careSchedules.filter(
          (s) => s.id !== scheduleId
        );
        this.saveSchedulesToStorage();
        this.showSuccess("ƒê√£ x√≥a l·ªãch chƒÉm s√≥c");

        // Close details modal if this schedule was being viewed
        if (this.selectedSchedule && this.selectedSchedule.id === scheduleId) {
          this.showScheduleDetails = false;
          this.selectedSchedule = null;
        }
      }
    },

    // Schedule Details Methods
    viewScheduleDetails(schedule) {
      this.selectedSchedule = schedule;
      this.showScheduleDetails = true;
    },

    closeScheduleDetails() {
      this.showScheduleDetails = false;
      this.selectedSchedule = null;
    },

    duplicateSchedule(schedule) {
      const duplicatedSchedule = {
        ...schedule,
        id: this.scheduleIdCounter++,
        plantName: `${schedule.plantName} (Sao ch√©p)`,
        startDate: new Date(),
        completedDates: [],
        createdAt: new Date(),
      };

      this.careSchedules.push(duplicatedSchedule);
      this.saveSchedulesToStorage();
      this.showSuccess(
        `ƒê√£ sao ch√©p l·ªãch chƒÉm s√≥c cho ${duplicatedSchedule.plantName}`
      );
    },

    formatDateTime(date) {
      if (!date) return "";
      // Ensure we have a Date object
      const d = date instanceof Date ? date : new Date(date);
      // Check if date is valid
      if (isNaN(d.getTime())) return "Ng√†y kh√¥ng h·ª£p l·ªá";
      
      return d.toLocaleString("vi-VN", {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit",
      });
    },

    getScheduleProgress(schedule) {
      if (!schedule.repeatCount || schedule.repeatCount === 1) {
        return schedule.completedDates.length > 0
          ? "Ho√†n th√†nh"
          : "Ch∆∞a th·ª±c hi·ªán";
      }

      const completed = schedule.completedDates.length;
      const total = schedule.repeatCount;
      return `${completed}/${total} l·∫ßn`;
    },

    getProgressPercentage(schedule) {
      if (!schedule.repeatCount || schedule.repeatCount === 1) {
        return schedule.completedDates.length > 0 ? 100 : 0;
      }

      const completed = schedule.completedDates.length;
      const total = schedule.repeatCount;
      return Math.min((completed / total) * 100, 100);
    },

    getNextReminder(schedule) {
      if (!schedule || schedule.repeatType === "none") return null;

      try {
        const lastCompleted =
          schedule.completedDates && schedule.completedDates.length > 0
            ? new Date(
                Math.max(
                  ...schedule.completedDates.map((d) => {
                    const date = d instanceof Date ? d : new Date(d);
                    return date.getTime();
                  })
                )
              )
            : null;

        const startDate = schedule.startDate instanceof Date 
          ? schedule.startDate 
          : new Date(schedule.startDate);
        
        const baseDate = lastCompleted || startDate;
        const nextDate = new Date(baseDate);

        switch (schedule.repeatType) {
          case "daily":
            nextDate.setDate(nextDate.getDate() + 1);
            break;
          case "weekly":
            nextDate.setDate(nextDate.getDate() + 7);
            break;
          case "monthly":
            nextDate.setMonth(nextDate.getMonth() + 1);
            break;
          default:
            return null;
        }

        // Check if we've reached the repeat limit
        if (
          schedule.repeatCount &&
          schedule.completedDates &&
          schedule.completedDates.length >= schedule.repeatCount
        ) {
          return null;
        }

        return nextDate;
      } catch (error) {
        console.error("Error calculating next reminder:", error);
        return null;
      }
    },

    markAsDone(scheduleId) {
      const schedule = this.careSchedules.find((s) => s.id === scheduleId);
      if (schedule) {
        const now = new Date();
        schedule.completedDates.push(now);
        this.saveSchedulesToStorage();
        this.showSuccess(
          `ƒê√£ ho√†n th√†nh: ${this.getCareTypeName(schedule.careType)}`
        );

        // Add bot message
        const botMessage = {
          id: this.messageId++,
          type: "bot",
          content: `üéâ Tuy·ªát v·ªùi! B·∫°n ƒë√£ ho√†n th√†nh vi·ªác ${this.getCareTypeName(
            schedule.careType
          ).toLowerCase()} cho **${schedule.plantName}**.
          
          ${this.getEncouragementMessage(schedule.careType)}`,
          timestamp: new Date(),
        };
        this.messages.push(botMessage);
        this.scrollToBottom();
      }
    },

    getNextReminderDate(schedule) {
      const now = new Date();
      let nextDate = new Date(schedule.startDate);

      if (schedule.repeatType === "none") {
        return nextDate > now ? nextDate : null;
      }

      let count = 0;
      while (nextDate <= now && count < schedule.repeatCount) {
        switch (schedule.repeatType) {
          case "daily":
            nextDate.setDate(nextDate.getDate() + 1);
            break;
          case "weekly":
            nextDate.setDate(nextDate.getDate() + 7);
            break;
          case "monthly":
            nextDate.setMonth(nextDate.getMonth() + 1);
            break;
        }
        count++;
      }

      return count < schedule.repeatCount ? nextDate : null;
    },

    getCareTypeIcon(careType) {
      const icons = {
        watering: "üíß",
        fertilizing: "üå±",
        pruning: "‚úÇÔ∏è",
        repotting: "ü™¥",
        spraying: "üí®",
        checking: "üîç",
      };
      return icons[careType] || "üåø";
    },

    getCareTypeName(careType) {
      const names = {
        watering: "T∆∞·ªõi n∆∞·ªõc",
        fertilizing: "B√≥n ph√¢n",
        pruning: "T·ªâa c√†nh",
        repotting: "Thay ch·∫≠u",
        spraying: "Phun thu·ªëc",
        checking: "Ki·ªÉm tra s·ª©c kh·ªèe",
      };
      return names[careType] || "ChƒÉm s√≥c";
    },

    getRepeatText(schedule) {
      if (schedule.repeatType === "none") {
        return "Kh√¥ng l·∫∑p l·∫°i";
      }
      const typeNames = {
        daily: "h√†ng ng√†y",
        weekly: "h√†ng tu·∫ßn",
        monthly: "h√†ng th√°ng",
      };
      return `L·∫∑p l·∫°i ${typeNames[schedule.repeatType]} (${
        schedule.repeatCount
      } l·∫ßn)`;
    },

    getEncouragementMessage(careType) {
      const messages = {
        watering: "üíß C√¢y s·∫Ω r·∫•t kh·ªèe m·∫°nh v·ªõi vi·ªác t∆∞·ªõi n∆∞·ªõc ƒë·ªÅu ƒë·∫∑n!",
        fertilizing: "üå± Dinh d∆∞·ª°ng ƒë·∫ßy ƒë·ªß s·∫Ω gi√∫p c√¢y ph√°t tri·ªÉn m·∫°nh m·∫Ω!",
        pruning: "‚úÇÔ∏è Vi·ªác t·ªâa c√†nh gi√∫p c√¢y t·∫≠p trung nƒÉng l∆∞·ª£ng ph√°t tri·ªÉn!",
        repotting: "ü™¥ Kh√¥ng gian m·ªõi s·∫Ω gi√∫p r·ªÖ c√¢y ph√°t tri·ªÉn t·ªët h∆°n!",
        spraying: "üí® C√¢y ƒë∆∞·ª£c b·∫£o v·ªá kh·ªèi s√¢u b·ªánh r·ªìi!",
        checking: "üîç Theo d√µi th∆∞·ªùng xuy√™n gi√∫p ph√°t hi·ªán v·∫•n ƒë·ªÅ s·ªõm!",
      };
      return (
        messages[careType] ||
        "üåø Vi·ªác chƒÉm s√≥c ƒë·ªÅu ƒë·∫∑n l√† ch√¨a kh√≥a th√†nh c√¥ng!"
      );
    },

    formatReminderTime(date) {
      const now = new Date();
      const diff = date - now;
      const minutes = Math.floor(diff / (1000 * 60));
      const hours = Math.floor(minutes / 60);

      if (minutes < 60) {
        return `${minutes} ph√∫t n·ªØa`;
      } else if (hours < 24) {
        return `${hours} gi·ªù n·ªØa`;
      } else {
        return date.toLocaleDateString("vi-VN");
      }
    },

    setupReminderCheck() {
      // Check for reminders every minute
      this.reminderCheckInterval = setInterval(() => {
        this.checkUpcomingReminders();
      }, 60000);
    },

    checkUpcomingReminders() {
      const now = new Date();

      this.careSchedules.forEach((schedule) => {
        const nextDate = this.getNextReminderDate(schedule);
        if (nextDate) {
          const timeDiff = nextDate - now;

          // Remind 15 minutes before
          if (timeDiff > 0 && timeDiff <= 15 * 60 * 1000) {
            const lastNotified = localStorage.getItem(
              `notified_${schedule.id}`
            );
            const today = now.toDateString();

            if (lastNotified !== today) {
              this.showReminderNotification(schedule, nextDate);
              localStorage.setItem(`notified_${schedule.id}`, today);
            }
          }
        }
      });
    },

    showReminderNotification(schedule, nextDate) {
      const botMessage = {
        id: this.messageId++,
        type: "bot",
        content: `üîî **Nh·∫Øc nh·ªü chƒÉm s√≥c c√¢y!**
        
        ${this.getCareTypeIcon(schedule.careType)} **${schedule.plantName}**
        üìÖ ${this.getCareTypeName(schedule.careType)}
        ‚è∞ Trong ${this.formatReminderTime(nextDate)}
        
        ${schedule.notes ? `üìù ${schedule.notes}` : ""}
        
        Nh·ªõ chƒÉm s√≥c c√¢y nh√©! üåø`,
        timestamp: new Date(),
      };

      this.messages.push(botMessage);
      this.scrollToBottom();

      // Browser notification if permitted
      if (Notification.permission === "granted") {
        new Notification(`Nh·∫Øc nh·ªü chƒÉm s√≥c: ${schedule.plantName}`, {
          body: `${this.getCareTypeName(
            schedule.careType
          )} trong ${this.formatReminderTime(nextDate)}`,
          icon: "/favicon.ico",
        });
      }
    },

    closeScheduleModal() {
      this.showScheduleModal = false;
      this.newSchedule = {
        plantName: "",
        careType: "watering",
        startDate: "",
        repeatType: "none",
        repeatCount: 1,
        notes: "",
      };
      this.setDefaultStartDate();
    },

    closeScheduleList() {
      this.showScheduleList = false;
    },

    // Extract plant information from AI analysis
    extractPlantInfo(analysisText, structuredData) {
      let plantInfo = {
        name: null,
        scientificName: null,
        commonName: null,
        plantType: null,
        healthStatus: null,
        careRequirements: {},
      };

      try {
        // Try to parse structured data first
        if (structuredData) {
          for (const [key, value] of Object.entries(structuredData)) {
            if (key.includes("NH·∫¨N D·∫†NG") || key.includes("1.")) {
              if (value["T√™n khoa h·ªçc v√† t√™n th√¥ng th∆∞·ªùng"]) {
                const names = value["T√™n khoa h·ªçc v√† t√™n th√¥ng th∆∞·ªùng"];
                plantInfo.scientificName = names["T√™n khoa h·ªçc"] || null;
                plantInfo.commonName = names["T√™n th√¥ng th∆∞·ªùng"] || null;
                plantInfo.name =
                  plantInfo.commonName ||
                  plantInfo.scientificName ||
                  "C√¢y kh√¥ng x√°c ƒë·ªãnh";
              }
            } else if (key.includes("T√åNH TR·∫†NG") || key.includes("2.")) {
              plantInfo.healthStatus = value["T√¨nh tr·∫°ng t·ªïng th·ªÉ"] || null;
            } else if (key.includes("KHUY·∫æN NGH·ªä") || key.includes("4.")) {
              plantInfo.careRequirements = value || {};
            }
          }
        }

        // If no structured data, try to extract from text
        if (!plantInfo.name && analysisText) {
          const nameMatch = analysisText.match(
            /(?:t√™n th√¥ng th∆∞·ªùng|common name)[:\s]*([^,\n]+)/i
          );
          if (nameMatch) {
            plantInfo.name = nameMatch[1].trim();
          }
        }

        // Set default name if still null
        if (!plantInfo.name) {
          plantInfo.name = "C√¢y tr·ªìng ƒë∆∞·ª£c ph√¢n t√≠ch";
        }
      } catch (error) {
        console.error("Error extracting plant info:", error);
        plantInfo.name = "C√¢y tr·ªìng ƒë∆∞·ª£c ph√¢n t√≠ch";
      }

      return plantInfo;
    },

    // Auto-generate care schedule based on AI analysis
    async autoGenerateCareSchedule(plantInfo, analysisData) {
      try {
        const careSchedules = this.generateCareRecommendations(
          plantInfo,
          analysisData
        );

        if (careSchedules.length > 0) {
          // Show confirmation dialog
          const confirmed = await this.showAutoScheduleConfirmation(
            plantInfo.name,
            careSchedules
          );

          if (confirmed) {
            // Create schedules
            careSchedules.forEach((schedule) => {
              this.createAutoSchedule(schedule);
            });

            // Show success message
            const botMessage = {
              id: this.messageId++,
              type: "bot",
              content: `ü§ñ **T·ª± ƒë·ªông t·∫°o l·ªãch chƒÉm s√≥c!**
              
              T√¥i ƒë√£ t·ª± ƒë·ªông t·∫°o ${careSchedules.length} l·ªãch chƒÉm s√≥c cho **${
                plantInfo.name
              }** d·ª±a tr√™n k·∫øt qu·∫£ ph√¢n t√≠ch:
              
              ${careSchedules
                .map(
                  (s) =>
                    `${this.getCareTypeIcon(s.careType)} ${this.getCareTypeName(
                      s.careType
                    )} - ${s.frequency}`
                )
                .join("\n")}
              
              B·∫°n c√≥ th·ªÉ xem v√† ch·ªânh s·ª≠a trong m·ª•c "Xem l·ªãch" ·ªü sidebar! üìÖ`,
              timestamp: new Date(),
            };
            this.messages.push(botMessage);
            this.scrollToBottom();
          }
        }
      } catch (error) {
        console.error("Error generating auto schedule:", error);
      }
    },

    // Generate care recommendations based on plant type and health
    generateCareRecommendations(plantInfo, analysisData) {
      const schedules = [];
      const now = new Date();

      // Base watering schedule (most important)
      const wateringFrequency = this.determineWateringFrequency(plantInfo);
      schedules.push({
        plantName: plantInfo.name,
        careType: "watering",
        frequency: wateringFrequency.text,
        startDate: new Date(now.getTime() + 2 * 60 * 60 * 1000), // 2 hours from now
        repeatType: wateringFrequency.type,
        repeatCount: 30, // 1 month
        notes: `L·ªãch t∆∞·ªõi t·ª± ƒë·ªông d·ª±a tr√™n ph√¢n t√≠ch AI. ${wateringFrequency.note}`,
        autoGenerated: true,
      });

      // Fertilizing schedule if plant is healthy or needs nutrients
      if (this.needsFertilizing(plantInfo, analysisData)) {
        schedules.push({
          plantName: plantInfo.name,
          careType: "fertilizing",
          frequency: "H√†ng tu·∫ßn",
          startDate: new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000), // 1 week from now
          repeatType: "weekly",
          repeatCount: 8, // 2 months
          notes: "B√≥n ph√¢n ƒë·ªãnh k·ª≥ ƒë·ªÉ c√¢y ph√°t tri·ªÉn t·ªët h∆°n.",
          autoGenerated: true,
        });
      }

      // Health check schedule
      schedules.push({
        plantName: plantInfo.name,
        careType: "checking",
        frequency: "H√†ng tu·∫ßn",
        startDate: new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000), // 3 days from now
        repeatType: "weekly",
        repeatCount: 12, // 3 months
        notes: "Ki·ªÉm tra t√¨nh tr·∫°ng s·ª©c kh·ªèe v√† ph√°t hi·ªán s·ªõm c√°c v·∫•n ƒë·ªÅ.",
        autoGenerated: true,
      });

      // Disease treatment if unhealthy
      if (
        plantInfo.healthStatus &&
        plantInfo.healthStatus.toLowerCase().includes("b·ªánh")
      ) {
        schedules.push({
          plantName: plantInfo.name,
          careType: "spraying",
          frequency: "3 ng√†y m·ªôt l·∫ßn",
          startDate: new Date(now.getTime() + 12 * 60 * 60 * 1000), // 12 hours from now
          repeatType: "daily",
          repeatCount: 15, // Every 3 days for 45 days
          notes: "Phun thu·ªëc ƒëi·ªÅu tr·ªã b·ªánh theo khuy·∫øn ngh·ªã c·ªßa AI.",
          autoGenerated: true,
        });
      }

      return schedules;
    },

    // Determine watering frequency based on plant type
    determineWateringFrequency(plantInfo) {
      const plantName = (plantInfo.name || "").toLowerCase();
      const scientificName = (plantInfo.scientificName || "").toLowerCase();

      // Different plant types have different watering needs
      if (
        plantName.includes("x∆∞∆°ng r·ªìng") ||
        plantName.includes("cactus") ||
        scientificName.includes("cactaceae")
      ) {
        return {
          type: "weekly",
          text: "H√†ng tu·∫ßn",
          note: "C√¢y x∆∞∆°ng r·ªìng c·∫ßn √≠t n∆∞·ªõc, t∆∞·ªõi 1 tu·∫ßn/l·∫ßn.",
        };
      } else if (
        plantName.includes("hoa h·ªìng") ||
        scientificName.includes("rosa")
      ) {
        return {
          type: "daily",
          text: "2 ng√†y m·ªôt l·∫ßn",
          note: "Hoa h·ªìng c·∫ßn n∆∞·ªõc th∆∞·ªùng xuy√™n nh∆∞ng kh√¥ng qu√° ∆∞·ªõt.",
        };
      } else if (plantName.includes("lan") || plantName.includes("orchid")) {
        return {
          type: "daily",
          text: "3 ng√†y m·ªôt l·∫ßn",
          note: "Lan c·∫ßn ƒë·ªô ·∫©m v·ª´a ph·∫£i, tr√°nh √∫ng n∆∞·ªõc.",
        };
      } else if (plantName.includes("l√°") || plantName.includes("c·ªè")) {
        return {
          type: "daily",
          text: "H√†ng ng√†y",
          note: "C√¢y l√° xanh c·∫ßn n∆∞·ªõc th∆∞·ªùng xuy√™n.",
        };
      } else {
        // Default for unknown plants
        return {
          type: "daily",
          text: "2 ng√†y m·ªôt l·∫ßn",
          note: "L·ªãch t∆∞·ªõi ti√™u chu·∫©n cho c√¢y tr·ªìng th√¥ng th∆∞·ªùng.",
        };
      }
    },

    // Check if plant needs fertilizing
    needsFertilizing(plantInfo, analysisData) {
      // Check health status and growth analysis
      if (
        plantInfo.healthStatus &&
        plantInfo.healthStatus.toLowerCase().includes("kh·ªèe m·∫°nh")
      ) {
        return true; // Healthy plants benefit from regular fertilizing
      }

      // Check if analysis mentions nutrition issues
      if (analysisData) {
        const analysisText = JSON.stringify(analysisData).toLowerCase();
        if (
          analysisText.includes("dinh d∆∞·ª°ng") ||
          analysisText.includes("nutrition") ||
          analysisText.includes("ph√¢n b√≥n") ||
          analysisText.includes("fertilizer")
        ) {
          return true;
        }
      }

      return true; // Default to fertilizing for most plants
    },

    // Show confirmation dialog for auto-generated schedules
    async showAutoScheduleConfirmation(plantName, schedules) {
      return new Promise((resolve) => {
        const message = `ü§ñ AI ƒë·ªÅ xu·∫•t t·∫°o ${
          schedules.length
        } l·ªãch chƒÉm s√≥c cho "${plantName}":\n\n${schedules
          .map(
            (s) =>
              `${this.getCareTypeIcon(s.careType)} ${this.getCareTypeName(
                s.careType
              )} - ${s.frequency}`
          )
          .join("\n")}\n\nB·∫°n c√≥ mu·ªën t·ª± ƒë·ªông t·∫°o c√°c l·ªãch n√†y kh√¥ng?`;

        if (confirm(message)) {
          resolve(true);
        } else {
          resolve(false);
        }
      });
    },

    // Create auto-generated schedule
    createAutoSchedule(scheduleData) {
      const schedule = {
        id: this.scheduleIdCounter++,
        plantName: scheduleData.plantName,
        careType: scheduleData.careType,
        startDate: scheduleData.startDate,
        repeatType: scheduleData.repeatType,
        repeatCount: scheduleData.repeatCount,
        notes: scheduleData.notes,
        completedDates: [],
        createdAt: new Date(),
        autoGenerated: true, // Mark as auto-generated
      };

      this.careSchedules.push(schedule);
      this.saveSchedulesToStorage();
    },

    requestNotificationPermission() {
      if ("Notification" in window && Notification.permission === "default") {
        Notification.requestPermission().then((permission) => {
          if (permission === "granted") {
            this.showSuccess("ƒê√£ b·∫≠t th√¥ng b√°o nh·∫Øc nh·ªü chƒÉm s√≥c c√¢y!");
          }
        });
      }
    },
  },
};
</script>

<style scoped>
.chat-container {
  display: flex;
  height: 100vh;
  max-width: 1200px;
  margin: 0 auto;
  background: white;
  box-shadow: 0 0 50px rgba(0, 0, 0, 0.1);
}

.sidebar {
  width: 300px;
  background: #2c3e50;
  color: white;
  padding: 20px;
  overflow-y: auto;
}

.logo {
  text-align: center;
  margin-bottom: 30px;
  padding-bottom: 20px;
  border-bottom: 1px solid #34495e;
}

.logo h1 {
  font-size: 24px;
  color: #2ecc71;
  margin-bottom: 5px;
}

.logo p {
  font-size: 14px;
  color: #bdc3c7;
}

.chat-info {
  background: #34495e;
  padding: 15px;
  border-radius: 10px;
  margin-bottom: 20px;
}

.chat-info h3 {
  color: #2ecc71;
  margin-bottom: 10px;
  font-size: 16px;
}

.chat-info ul {
  list-style: none;
  font-size: 14px;
  line-height: 1.6;
}

.chat-info li {
  margin-bottom: 5px;
  color: #ecf0f1;
}

.chat-info li:before {
  content: "üå± ";
  margin-right: 5px;
}

.main-chat {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #f8f9fa;
}

.chat-header {
  background: #2ecc71;
  color: white;
  padding: 20px;
  text-align: center;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.chat-header h2 {
  font-size: 20px;
  margin-bottom: 5px;
}

.chat-header p {
  font-size: 14px;
  opacity: 0.9;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  background: #ffffff;
}

.message {
  display: flex;
  margin-bottom: 20px;
  animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message.user {
  justify-content: flex-end;
}

.message.bot {
  justify-content: flex-start;
}

.message-content {
  max-width: 70%;
  padding: 15px 20px;
  border-radius: 20px;
  position: relative;
  word-wrap: break-word;
}

.message.user .message-content {
  background: #2ecc71;
  color: white;
  border-bottom-right-radius: 5px;
}

.message.bot .message-content {
  background: #ecf0f1;
  color: #2c3e50;
  border-bottom-left-radius: 5px;
}

.message-time {
  font-size: 12px;
  opacity: 0.7;
  margin-top: 5px;
}

.analysis-result {
  background: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 10px;
  padding: 15px;
  margin: 10px 0;
}

.analysis-section {
  margin-bottom: 15px;
}

.analysis-section h4 {
  color: #2ecc71;
  margin-bottom: 8px;
  font-size: 14px;
  display: flex;
  align-items: center;
}

.analysis-section h4 i {
  margin-right: 8px;
}

.analysis-section p,
.analysis-section li {
  font-size: 13px;
  line-height: 1.5;
  color: #495057;
}

.analysis-section ul {
  padding-left: 20px;
}

.image-preview img {
  max-width: 200px;
  border-radius: 10px;
  margin: 10px 0;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.chat-input-container {
  padding: 20px;
  background: white;
  border-top: 1px solid #dee2e6;
}

.chat-input-wrapper {
  display: flex;
  gap: 10px;
  align-items: flex-end;
}

.image-upload {
  position: relative;
}

.image-upload input[type="file"] {
  display: none;
}

.image-upload label {
  background: #f8f9fa;
  border: 2px dashed #dee2e6;
  border-radius: 10px;
  padding: 10px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 60px;
  height: 60px;
  transition: all 0.3s ease;
}

.image-upload label:hover {
  background: #e9ecef;
  border-color: #2ecc71;
}

.image-upload label.has-image {
  border-color: #2ecc71;
  background: #d4edda;
}

.image-upload label i {
  font-size: 20px;
  color: #6c757d;
}

.chat-input {
  flex: 1;
  padding: 15px 20px;
  border: 2px solid #dee2e6;
  border-radius: 25px;
  font-size: 16px;
  outline: none;
  transition: border-color 0.3s ease;
  resize: none;
  min-height: 60px;
  max-height: 120px;
}

.chat-input:focus {
  border-color: #2ecc71;
}

.send-button {
  background: #2ecc71;
  color: white;
  border: none;
  border-radius: 50%;
  width: 60px;
  height: 60px;
  cursor: pointer;
  transition: background 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.send-button:hover:not(:disabled) {
  background: #27ae60;
}

.send-button:disabled {
  background: #bdc3c7;
  cursor: not-allowed;
}

.send-button i {
  font-size: 20px;
}

.typing-indicator {
  display: flex;
  align-items: center;
  padding: 15px 20px;
  background: #ecf0f1;
  border-radius: 20px;
  margin-bottom: 20px;
  max-width: 70%;
}

.typing-dots {
  display: flex;
  gap: 4px;
}

.typing-dots span {
  width: 8px;
  height: 8px;
  background: #95a5a6;
  border-radius: 50%;
  animation: typing 1.5s infinite ease-in-out;
}

.typing-dots span:nth-child(2) {
  animation-delay: 0.2s;
}

.typing-dots span:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes typing {
  0%,
  60%,
  100% {
    transform: translateY(0);
    opacity: 0.5;
  }
  30% {
    transform: translateY(-10px);
    opacity: 1;
  }
}

.typing-text {
  margin-left: 10px;
  color: #7f8c8d;
  font-size: 14px;
}

.error-message {
  background: #e74c3c;
  color: white;
  padding: 10px 15px;
  border-radius: 10px;
  margin: 10px 0;
  font-size: 14px;
}

.success-message {
  background: #2ecc71;
  color: white;
  padding: 10px 15px;
  border-radius: 10px;
  margin: 10px 0;
  font-size: 14px;
}

@media (max-width: 768px) {
  .chat-container {
    flex-direction: column;
  }

  .sidebar {
    width: 100%;
    height: auto;
    max-height: 200px;
  }

  .message-content {
    max-width: 85%;
  }
}

/* Schedule Management Styles */
.schedule-stats {
  font-size: 12px;
  color: #bdc3c7;
  margin-bottom: 15px;
}

.schedule-stats p {
  margin: 3px 0;
}

.create-schedule-btn,
.view-schedule-btn {
  background: #2ecc71;
  color: white;
  border: none;
  border-radius: 20px;
  padding: 8px 15px;
  cursor: pointer;
  font-size: 12px;
  margin: 5px 0;
  width: 100%;
  transition: all 0.3s ease;
}

.create-schedule-btn:hover,
.view-schedule-btn:hover {
  background: #27ae60;
  transform: translateY(-2px);
}

.create-schedule-btn i,
.view-schedule-btn i {
  margin-right: 5px;
}

/* Modal Styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 20px;
}

.modal-content {
  background: white;
  border-radius: 15px;
  max-width: 500px;
  width: 100%;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  animation: modalSlideIn 0.3s ease-out;
}

.schedule-list-modal {
  max-width: 700px;
}

@keyframes modalSlideIn {
  from {
    opacity: 0;
    transform: scale(0.9) translateY(-20px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.modal-header {
  background: #2ecc71;
  color: white;
  padding: 20px;
  border-radius: 15px 15px 0 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header h3 {
  margin: 0;
  font-size: 18px;
}

.close-btn {
  background: none;
  border: none;
  color: white;
  font-size: 18px;
  cursor: pointer;
  padding: 5px;
  border-radius: 50%;
  transition: background 0.3s ease;
}

.close-btn:hover {
  background: rgba(255, 255, 255, 0.2);
}

.modal-body {
  padding: 20px;
}

.modal-footer {
  padding: 20px;
  border-top: 1px solid #dee2e6;
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}

/* Form Styles */
.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  font-weight: bold;
  color: #2c3e50;
  font-size: 14px;
}

.form-group input,
.form-group select,
.form-group textarea {
  width: 100%;
  padding: 12px;
  border: 2px solid #dee2e6;
  border-radius: 8px;
  font-size: 14px;
  transition: border-color 0.3s ease;
  box-sizing: border-box;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  outline: none;
  border-color: #2ecc71;
}

.form-group textarea {
  resize: vertical;
  min-height: 80px;
}

.btn-primary,
.btn-secondary {
  padding: 10px 20px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.3s ease;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.btn-primary {
  background: #2ecc71;
  color: white;
}

.btn-primary:hover:not(:disabled) {
  background: #27ae60;
}

.btn-primary:disabled {
  background: #bdc3c7;
  cursor: not-allowed;
}

.btn-secondary {
  background: #6c757d;
  color: white;
}

.btn-secondary:hover {
  background: #5a6268;
}

/* Schedule List Styles */
.schedule-tabs {
  display: flex;
  border-bottom: 1px solid #dee2e6;
  margin-bottom: 20px;
}

.tab-btn {
  background: none;
  border: none;
  padding: 12px 20px;
  cursor: pointer;
  color: #6c757d;
  border-bottom: 2px solid transparent;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  gap: 8px;
}

.tab-btn.active {
  color: #2ecc71;
  border-bottom-color: #2ecc71;
}

.tab-btn:hover {
  color: #2ecc71;
}

.schedule-content {
  min-height: 300px;
}

.empty-state {
  text-align: center;
  padding: 40px 20px;
  color: #6c757d;
}

.empty-state i {
  font-size: 48px;
  margin-bottom: 16px;
  color: #dee2e6;
}

.empty-state p {
  margin-bottom: 20px;
}

/* Reminder and Schedule Items */
.reminder-item,
.schedule-item {
  display: flex;
  align-items: center;
  padding: 15px;
  border: 1px solid #dee2e6;
  border-radius: 10px;
  margin-bottom: 10px;
  transition: all 0.3s ease;
}

.reminder-item:hover,
.schedule-item:hover {
  border-color: #2ecc71;
  box-shadow: 0 2px 10px rgba(46, 204, 113, 0.1);
}

.reminder-item.urgent {
  border-color: #e74c3c;
  background: #fdf2f2;
}

.reminder-icon,
.schedule-icon {
  font-size: 24px;
  margin-right: 15px;
  width: 40px;
  text-align: center;
}

.reminder-info,
.schedule-info {
  flex: 1;
}

.reminder-info h4,
.schedule-info h4 {
  margin: 0 0 5px 0;
  color: #2c3e50;
  font-size: 16px;
}

.reminder-info p,
.schedule-info p {
  margin: 2px 0;
  color: #6c757d;
  font-size: 14px;
}

.reminder-time {
  color: #e74c3c;
  font-weight: bold;
  font-size: 12px;
}

.schedule-repeat {
  color: #2ecc71;
  font-size: 12px;
}

.schedule-notes {
  font-style: italic;
  color: #8b8b8b;
  font-size: 12px;
}

.auto-badge {
  display: inline-block;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 10px;
  margin-left: 8px;
  font-weight: normal;
  vertical-align: middle;
}

.done-btn {
  background: #2ecc71;
  color: white;
  border: none;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.done-btn:hover {
  background: #27ae60;
  transform: scale(1.1);
}

.schedule-actions {
  display: flex;
  gap: 8px;
}

.edit-btn,
.delete-btn {
  background: none;
  border: 1px solid;
  border-radius: 6px;
  width: 32px;
  height: 32px;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.edit-btn {
  border-color: #17a2b8;
  color: #17a2b8;
}

.edit-btn:hover {
  background: #17a2b8;
  color: white;
}

.delete-btn {
  border-color: #dc3545;
  color: #dc3545;
}

.delete-btn:hover {
  background: #dc3545;
  color: white;
}

/* Responsive Design */
@media (max-width: 768px) {
  .modal-content {
    margin: 10px;
    max-width: none;
  }

  .modal-header,
  .modal-body,
  .modal-footer {
    padding: 15px;
  }

  .reminder-item,
  .schedule-item {
    padding: 12px;
  }

  .form-group input,
  .form-group select,
  .form-group textarea {
    padding: 10px;
  }
}

/* Schedule Details Modal Styles */
.schedule-details-modal {
  max-width: 600px !important;
  max-height: 90vh;
  overflow-y: auto;
}

.schedule-detail-section {
  padding: 20px 0;
}

.detail-item {
  display: flex;
  align-items: flex-start;
  margin-bottom: 20px;
  padding: 15px;
  background: #f8fffe;
  border-radius: 10px;
  border: 1px solid #e0f0ef;
}

.detail-item label {
  font-weight: 600;
  color: #2c5530;
  min-width: 140px;
  margin-right: 15px;
  font-size: 14px;
}

.detail-value {
  flex: 1;
  color: #34495e;
  font-size: 14px;
  line-height: 1.5;
}

.notes-text {
  background: #fff;
  padding: 10px;
  border-radius: 6px;
  border: 1px solid #ddd;
  font-style: italic;
}

.status-active {
  color: #27ae60;
  font-weight: 600;
  background: #d5f4e6;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
}

.progress-info {
  flex: 1;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: #ecf0f1;
  border-radius: 4px;
  margin-top: 8px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #27ae60, #2ecc71);
  border-radius: 4px;
  transition: width 0.3s ease;
}

.next-reminder {
  color: #e67e22;
  font-weight: 500;
}

.next-reminder small {
  display: block;
  color: #7f8c8d;
  font-size: 12px;
  margin-top: 4px;
}

.schedule-actions-detail {
  display: flex;
  gap: 10px;
  justify-content: center;
  padding: 20px 0;
  border-top: 1px solid #ecf0f1;
  margin-top: 20px;
}

.schedule-actions-detail button {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
}

.btn-primary {
  background: #3498db;
  color: white;
}

.btn-primary:hover {
  background: #2980b9;
  transform: translateY(-2px);
}

.btn-secondary {
  background: #95a5a6;
  color: white;
}

.btn-secondary:hover {
  background: #7f8c8d;
  transform: translateY(-2px);
}

.btn-danger {
  background: #e74c3c;
  color: white;
}

.btn-danger:hover {
  background: #c0392b;
  transform: translateY(-2px);
}

/* View button style */
.view-btn {
  background: #3498db;
  color: white;
  border: none;
  padding: 8px 12px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 12px;
}

.view-btn:hover {
  background: #2980b9;
  transform: translateY(-1px);
}

.schedule-actions {
  display: flex;
  gap: 5px;
}
</style>
